{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nvar _jsxFileName = \"/Users/jessicsw/Desktop/Projects/Counter/node_modules/react-navigation-fluid-transitions/TransitionItemsView.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport UIManager from \"react-native-web/dist/exports/UIManager\";\nimport Easing from \"react-native-web/dist/exports/Easing\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport findNodeHandle from \"react-native-web/dist/exports/findNodeHandle\";\nimport PropTypes from 'prop-types';\nimport { ScreenContainer } from 'react-native-screens';\nimport { Metrics, NavigationDirection, RouteDirection } from \"./Types\";\nimport TransitionItem from \"./TransitionItem\";\nimport TransitionItems from \"./TransitionItems\";\nimport TransitionOverlayView from \"./TransitionOverlayView\";\n\nvar TransitionItemsView = function (_React$Component) {\n  _inherits(TransitionItemsView, _React$Component);\n\n  var _super = _createSuper(TransitionItemsView);\n\n  function TransitionItemsView(props) {\n    var _this;\n\n    _classCallCheck(this, TransitionItemsView);\n\n    _this = _super.call(this, props);\n    _this._shouldRunStartAnimation = true;\n\n    _this.getDirectionForRoute = function (name, route) {\n      var _this$state = _this.state,\n          fromRoute = _this$state.fromRoute,\n          toRoute = _this$state.toRoute;\n\n      if (!fromRoute && !toRoute) {\n        return RouteDirection.unknown;\n      }\n\n      if (!fromRoute) {\n        return RouteDirection.to;\n      }\n\n      if (route === fromRoute) {\n        return RouteDirection.from;\n      }\n\n      if (route === toRoute) {\n        return RouteDirection.to;\n      }\n\n      return RouteDirection.unknown;\n    };\n\n    _this.getTransitionProgress = function () {\n      var useNative = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      if (useNative) return _this._transitionProgress;\n\n      if (!_this._nonNativeTransitionProgress) {\n        _this._nonNativeTransitionProgress = new Animated.Value(-1);\n\n        _this._transitionProgress.addListener(Animated.event([{\n          value: _this._nonNativeTransitionProgress\n        }], {\n          useNativeDriver: false\n        }));\n      }\n\n      return _this._nonNativeTransitionProgress;\n    };\n\n    _this.getRoutes = function () {\n      var _this$state2 = _this.state,\n          fromRoute = _this$state2.fromRoute,\n          toRoute = _this$state2.toRoute;\n      return [fromRoute, toRoute].filter(function (r) {\n        return r !== null;\n      });\n    };\n\n    _this.getIsAnchored = function (name, route) {\n      var item = _this._transitionItems.getItemByNameAndRoute(name, route);\n\n      if (!item) return false;\n      var _this$state3 = _this.state,\n          fromRoute = _this$state3.fromRoute,\n          toRoute = _this$state3.toRoute;\n\n      var sharedElements = _this._transitionItems.getSharedElements(fromRoute, toRoute);\n\n      if (sharedElements && sharedElements.find(function (p) {\n        return p.fromItem.name === item.anchor && p.fromItem.route === route;\n      }) || sharedElements.find(function (p) {\n        return p.toItem.name === item.anchor && p.toItem.route === route;\n      })) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.getItemByNameAndRoute = function (name, route) {\n      return _this._transitionItems.getItemByNameAndRoute(name, route);\n    };\n\n    _this.getItemDelayInfo = function (name, route) {\n      var _this$state4 = _this.state,\n          fromRoute = _this$state4.fromRoute,\n          toRoute = _this$state4.toRoute;\n\n      var transitionElements = _this._transitionItems.getItems().filter(function (itm) {\n        return itm.route === route && !itm.shared && itm.delay;\n      });\n\n      var delayCount = transitionElements.length + 1;\n      var delayFactor = 0;\n      var delayIndex = 0;\n\n      if (fromRoute === route) {\n        delayFactor = 1;\n        delayIndex = 0;\n      } else if (toRoute === route) {\n        delayFactor = -1;\n        delayIndex = delayCount - 1;\n      }\n\n      for (var i = 0; i < transitionElements.length; i++) {\n        delayIndex += delayFactor;\n\n        if (transitionElements[i].name === name && transitionElements[i].route === route) {\n          break;\n        }\n      }\n\n      return {\n        delayCount: delayCount,\n        delayIndex: delayIndex\n      };\n    };\n\n    _this.getIsPartOfSharedTransition = function (name, route) {\n      var item = _this._transitionItems.getItemByNameAndRoute(name, route);\n\n      if (!item || !item.shared) return false;\n      var _this$state5 = _this.state,\n          fromRoute = _this$state5.fromRoute,\n          toRoute = _this$state5.toRoute;\n\n      var sharedElements = _this._transitionItems.getSharedElements(fromRoute, toRoute);\n\n      if (sharedElements.find(function (pair) {\n        return pair.fromItem.name === item.name && pair.fromItem.route === item.route || pair.toItem.name === item.name && pair.toItem.route === item.route;\n      })) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this.getDirection = function () {\n      var direction = _this.state.direction;\n      return direction;\n    };\n\n    _this.getIndex = function () {\n      var index = _this.state.index;\n      return index;\n    };\n\n    _this.getIsPartOfTransition = function (name, route) {\n      var item = _this._transitionItems.getItemByNameAndRoute(name, route);\n\n      if (!item || !(item.appear || item.disappear)) return false;\n      var _this$state6 = _this.state,\n          fromRoute = _this$state6.fromRoute,\n          toRoute = _this$state6.toRoute;\n\n      var transitionElements = _this._transitionItems.getTransitionElements(fromRoute, toRoute);\n\n      if (transitionElements.find(function (o) {\n        return item.name === o.name && item.route === o.route;\n      })) {\n        return true;\n      }\n\n      return false;\n    };\n\n    _this._inUpdate = false;\n    _this._isMounted = false;\n    _this._viewRef = null;\n    _this.state = {\n      toRoute: null,\n      fromRoute: null,\n      direction: NavigationDirection.Unknown,\n      sharedElements: null,\n      transitionElements: null,\n      index: -1\n    };\n    _this._transitionItems = new TransitionItems();\n    _this._transitionProgress = props.progress;\n\n    _this._transitionProgress.setValue(-1);\n\n    _this._interactionDonePromise = new Promise(function (resolve) {\n      return _this._interactionDonePromiseDone = resolve;\n    });\n    return _this;\n  }\n\n  _createClass(TransitionItemsView, [{\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      this.updateFromProps(nextProps, this.props);\n    }\n  }, {\n    key: \"updateFromProps\",\n    value: function updateFromProps(props, prevProps) {\n      if (!this._isMounted) return;\n      var fromRoute = props.fromRoute,\n          toRoute = props.toRoute;\n      var direction = props.index >= (prevProps ? prevProps.index : Number.MIN_SAFE_INTEGER) ? NavigationDirection.forward : NavigationDirection.back;\n      var index = prevProps ? props.index : 0;\n\n      if (toRoute !== this.state.toRoute || fromRoute !== this.state.fromRoute || index !== this.state.index || direction !== this.state.direction) {\n        this.setState({\n          toRoute: toRoute,\n          fromRoute: fromRoute,\n          direction: direction,\n          index: index\n        });\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props = this.props,\n          style = _this$props.style,\n          children = _this$props.children;\n      var _this$state7 = this.state,\n          direction = _this$state7.direction,\n          fromRoute = _this$state7.fromRoute,\n          toRoute = _this$state7.toRoute,\n          index = _this$state7.index,\n          sharedElements = _this$state7.sharedElements,\n          transitionElements = _this$state7.transitionElements;\n      return React.createElement(View, _extends({}, this.props, {\n        style: [styles.container, style],\n        ref: function ref(_ref) {\n          return _this2._viewRef = _ref;\n        },\n        collapsable: false,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 113,\n          columnNumber: 7\n        }\n      }), React.createElement(ScreenContainer, {\n        style: _objectSpread({}, StyleSheet.absoluteFillObject),\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 119,\n          columnNumber: 9\n        }\n      }, children), React.createElement(TransitionOverlayView, {\n        direction: direction,\n        fromRoute: fromRoute,\n        toRoute: toRoute,\n        index: index,\n        sharedElements: sharedElements,\n        transitionElements: transitionElements,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 122,\n          columnNumber: 9\n        }\n      }));\n    }\n  }, {\n    key: \"getViewMetrics\",\n    value: function getViewMetrics() {\n      var nodeHandle, viewMetrics, promise;\n      return _regeneratorRuntime.async(function getViewMetrics$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              nodeHandle = findNodeHandle(this._viewRef);\n\n              if (nodeHandle) {\n                _context.next = 3;\n                break;\n              }\n\n              return _context.abrupt(\"return\", viewMetrics);\n\n            case 3:\n              promise = new Promise(function (resolve) {\n                UIManager.measureInWindow(nodeHandle, function (x, y, width, height) {\n                  viewMetrics = {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                  };\n                  resolve();\n                });\n              });\n              _context.next = 6;\n              return _regeneratorRuntime.awrap(promise);\n\n            case 6:\n              return _context.abrupt(\"return\", viewMetrics);\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"measureItems\",\n    value: function measureItems(sharedElements, transitionElements) {\n      var promises, viewMetrics, i, pair, n, _n, _i;\n\n      return _regeneratorRuntime.async(function measureItems$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              promises = [];\n              _context2.next = 3;\n              return _regeneratorRuntime.awrap(this.getViewMetrics());\n\n            case 3:\n              viewMetrics = _context2.sent;\n\n              if (sharedElements) {\n                for (i = 0; i < sharedElements.length; i++) {\n                  pair = sharedElements[i];\n                  promises.push(this.measureItem(viewMetrics, pair.fromItem));\n                  promises.push(this.measureItem(viewMetrics, pair.toItem));\n\n                  if (pair.fromItem && pair.fromItem.anchors) {\n                    for (n = 0; n < pair.fromItem.anchors.length; n++) {\n                      promises.push(this.measureItem(viewMetrics, pair.fromItem.anchors[n]));\n                    }\n                  }\n\n                  if (pair.toItem && pair.toItem.anchors) {\n                    for (_n = 0; _n < pair.toItem.anchors.length; _n++) {\n                      promises.push(this.measureItem(viewMetrics, pair.toItem.anchors[_n]));\n                    }\n                  }\n                }\n              }\n\n              if (transitionElements) {\n                for (_i = 0; _i < transitionElements.length; _i++) {\n                  promises.push(this.measureItem(viewMetrics, transitionElements[_i]));\n                }\n              }\n\n              if (!(promises.length > 0)) {\n                _context2.next = 9;\n                break;\n              }\n\n              _context2.next = 9;\n              return _regeneratorRuntime.awrap(Promise.all(promises));\n\n            case 9:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"measureItem\",\n    value: function measureItem(viewMetrics, item) {\n      var nodeHandle;\n      return _regeneratorRuntime.async(function measureItem$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              nodeHandle = item.getNodeHandle();\n\n              if (nodeHandle) {\n                _context3.next = 3;\n                break;\n              }\n\n              return _context3.abrupt(\"return\");\n\n            case 3:\n              _context3.next = 5;\n              return _regeneratorRuntime.awrap(new Promise(function (resolve) {\n                UIManager.measureInWindow(nodeHandle, function (x, y, width, height) {\n                  item.updateMetrics(viewMetrics, {\n                    x: x,\n                    y: y,\n                    width: width,\n                    height: height\n                  });\n                  resolve();\n                });\n              }));\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, null, null, null, Promise);\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      var _this3 = this;\n\n      if (this._inUpdate) return;\n      var _this$state8 = this.state,\n          fromRoute = _this$state8.fromRoute,\n          toRoute = _this$state8.toRoute;\n      if (!fromRoute && !toRoute) return;\n      this._inUpdate = true;\n\n      var measureAndUpdateFunc = function measureAndUpdateFunc() {\n        var sharedElements, transitionElements;\n        return _regeneratorRuntime.async(function measureAndUpdateFunc$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                sharedElements = _this3._transitionItems.getSharedElements(fromRoute, toRoute);\n                transitionElements = _this3._transitionItems.getTransitionElements(fromRoute, toRoute);\n                _context4.next = 4;\n                return _regeneratorRuntime.awrap(_this3._interactionDonePromise);\n\n              case 4:\n                _context4.next = 6;\n                return _regeneratorRuntime.awrap(_this3.measureItems(sharedElements, transitionElements));\n\n              case 6:\n                if (!sharedElements.find(function (p) {\n                  return !p.fromItem.metrics || !p.toItem.metrics;\n                }) && !transitionElements.find(function (i) {\n                  return !i.metrics;\n                })) {\n                  _this3._transitionItems.getItems().forEach(function (item) {\n                    return item.forceUpdate();\n                  });\n\n                  _this3.setState(function (prevState) {\n                    return _objectSpread(_objectSpread({}, prevState), {}, {\n                      sharedElements: sharedElements,\n                      transitionElements: transitionElements\n                    });\n                  }, function () {\n                    var onLayout = _this3.props.onLayout;\n                    if (onLayout) onLayout();\n\n                    _this3._runStartAnimation(transitionElements.length);\n\n                    _this3._inUpdate = false;\n                  });\n                }\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, null, null, null, Promise);\n      };\n\n      measureAndUpdateFunc = measureAndUpdateFunc.bind(this);\n      setTimeout(measureAndUpdateFunc, 10);\n    }\n  }, {\n    key: \"_runStartAnimation\",\n    value: function _runStartAnimation(numberOfTransitions) {\n      var getTransitionConfig, _this$props2, toRoute, navigation, index, transitionSpec, timing, animations;\n\n      return _regeneratorRuntime.async(function _runStartAnimation$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              if (this._shouldRunStartAnimation) {\n                _context5.next = 2;\n                break;\n              }\n\n              return _context5.abrupt(\"return\");\n\n            case 2:\n              this._shouldRunStartAnimation = false;\n              getTransitionConfig = this.context.getTransitionConfig;\n              _this$props2 = this.props, toRoute = _this$props2.toRoute, navigation = _this$props2.navigation, index = _this$props2.index;\n\n              if (index > 0) {\n                this._transitionProgress.setValue(index - 1);\n              }\n\n              transitionSpec = getTransitionConfig ? getTransitionConfig(toRoute, navigation) : {\n                timing: Animated.timing,\n                duration: 650,\n                easing: Easing.inOut(Easing.poly(4)),\n                isInteraction: true,\n                useNativeDriver: true\n              };\n              timing = transitionSpec.timing;\n              delete transitionSpec.timing;\n              animations = [timing(this._transitionProgress, _objectSpread(_objectSpread({}, transitionSpec), {}, {\n                duration: numberOfTransitions === 0 ? 25 : transitionSpec.duration,\n                toValue: index\n              }))];\n              Animated.parallel(animations).start();\n\n            case 11:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, null, this, null, Promise);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this._isMounted = true;\n      this.updateFromProps(_objectSpread(_objectSpread({}, this.props), {}, {\n        index: -1\n      }));\n      var _this$props3 = this.props,\n          fromRoute = _this$props3.fromRoute,\n          toRoute = _this$props3.toRoute;\n\n      var te = this._transitionItems.getTransitionElements(fromRoute, toRoute);\n\n      if (te.length > 0) {\n        InteractionManager.runAfterInteractions(this._interactionDonePromiseDone);\n      } else {\n        this._interactionDonePromiseDone();\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this._isMounted = false;\n    }\n  }, {\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      var _this4 = this;\n\n      return {\n        register: function register(item) {\n          return _this4._transitionItems.add(item);\n        },\n        unregister: function unregister(name, route) {\n          return _this4._transitionItems.remove(name, route);\n        },\n        getTransitionProgress: this.getTransitionProgress,\n        getDirectionForRoute: this.getDirectionForRoute,\n        getIndex: function getIndex() {\n          return _this4.getIndex();\n        },\n        getDirection: function getDirection() {\n          return _this4.getDirection() || NavigationDirection.unknown;\n        },\n        getIsPartOfSharedTransition: this.getIsPartOfSharedTransition,\n        getIsPartOfTransition: this.getIsPartOfTransition,\n        getIsAnchored: this.getIsAnchored,\n        getRoutes: this.getRoutes,\n        getItemByNameAndRoute: this.getItemByNameAndRoute,\n        getItemDelayInfo: this.getItemDelayInfo\n      };\n    }\n  }]);\n\n  return TransitionItemsView;\n}(React.Component);\n\nTransitionItemsView.childContextTypes = {\n  register: PropTypes.func,\n  unregister: PropTypes.func,\n  getTransitionProgress: PropTypes.func,\n  getDirectionForRoute: PropTypes.func,\n  getDirection: PropTypes.func,\n  getIndex: PropTypes.func,\n  getIsPartOfSharedTransition: PropTypes.func,\n  getIsPartOfTransition: PropTypes.func,\n  getRoutes: PropTypes.func,\n  getIsAnchored: PropTypes.func,\n  getItemByNameAndRoute: PropTypes.func,\n  getItemDelayInfo: PropTypes.func\n};\nTransitionItemsView.contextTypes = {\n  getTransitionConfig: PropTypes.func\n};\nexport { TransitionItemsView as default };\nvar styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    overflow: 'hidden'\n  }\n});","map":{"version":3,"sources":["/Users/jessicsw/Desktop/Projects/Counter/node_modules/react-navigation-fluid-transitions/TransitionItemsView.js"],"names":["React","PropTypes","ScreenContainer","Metrics","NavigationDirection","RouteDirection","TransitionItem","TransitionItems","TransitionOverlayView","TransitionItemsView","props","_shouldRunStartAnimation","getDirectionForRoute","name","route","state","fromRoute","toRoute","unknown","to","from","getTransitionProgress","useNative","_transitionProgress","_nonNativeTransitionProgress","Animated","Value","addListener","event","value","useNativeDriver","getRoutes","filter","r","getIsAnchored","item","_transitionItems","getItemByNameAndRoute","sharedElements","getSharedElements","find","p","fromItem","anchor","toItem","getItemDelayInfo","transitionElements","getItems","itm","shared","delay","delayCount","length","delayFactor","delayIndex","i","getIsPartOfSharedTransition","pair","getDirection","direction","getIndex","index","getIsPartOfTransition","appear","disappear","getTransitionElements","o","_inUpdate","_isMounted","_viewRef","Unknown","progress","setValue","_interactionDonePromise","Promise","resolve","_interactionDonePromiseDone","nextProps","updateFromProps","prevProps","Number","MIN_SAFE_INTEGER","forward","back","setState","style","children","styles","container","ref","StyleSheet","absoluteFillObject","nodeHandle","findNodeHandle","viewMetrics","promise","UIManager","measureInWindow","x","y","width","height","promises","getViewMetrics","push","measureItem","anchors","n","all","getNodeHandle","updateMetrics","measureAndUpdateFunc","measureItems","metrics","forEach","forceUpdate","prevState","onLayout","_runStartAnimation","bind","setTimeout","numberOfTransitions","getTransitionConfig","context","navigation","transitionSpec","timing","duration","easing","Easing","inOut","poly","isInteraction","animations","toValue","parallel","start","te","InteractionManager","runAfterInteractions","register","add","unregister","remove","Component","childContextTypes","func","contextTypes","create","flex","overflow"],"mappings":"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","sourcesContent":["import React from 'react';\nimport {\n  View,\n  StyleSheet,\n  UIManager,\n  Easing,\n  InteractionManager,\n  Animated,\n  findNodeHandle,\n} from 'react-native';\nimport PropTypes from 'prop-types';\nimport { ScreenContainer } from 'react-native-screens';\n\nimport { Metrics, NavigationDirection, RouteDirection } from './Types';\nimport TransitionItem from './TransitionItem';\nimport TransitionItems from './TransitionItems';\nimport TransitionOverlayView from './TransitionOverlayView';\n\ntype State = {\n  fromRoute: ?string,\n  toRoute: ?string,\n  direction: NavigationDirection,\n  index: number,\n  sharedElements: ?Array<any>,\n  transitionElements: ?Array<TransitionItem>\n}\n\ntype Props = {\n  children: Array<any>,\n  progress: Animated.Value,\n  fromRoute: string,\n  toRoute: string,\n  index: ?number,\n  navigation: any,\n  style: StyleSheet.Styles,\n  onLayout: (evt: any) => void,\n}\n\nexport default class TransitionItemsView extends React.Component<\n  Props, State> {\n  constructor(props) {\n    super(props);\n    this._isMounted = false;\n    this._viewRef = null;\n\n    this.state = {\n      toRoute: null,\n      fromRoute: null,\n      direction: NavigationDirection.Unknown,\n      sharedElements: null,\n      transitionElements: null,\n      index: -1,\n    };\n\n    this._transitionItems = new TransitionItems();\n    this._transitionProgress = props.progress;\n    this._transitionProgress.setValue(-1); // Reset to handle first transition\n    // this._transitionProgress.addListener(console.log);\n\n    this._interactionDonePromise = new Promise(\n      resolve => this._interactionDonePromiseDone = resolve,\n    );\n  }\n\n  _viewRef: ?View;\n\n  _viewMetrics: Metrics;\n\n  _transitionItems: TransitionItems;\n\n  _isMounted: boolean;\n\n  _transitionProgress: Animated.Value;\n\n  _nonNativeTransitionProgress: Animated.Value;\n\n  _interactionDonePromise: Promise;\n\n  _interactionDonePromiseDone: Function;\n\n  _shouldRunStartAnimation: boolean = true;\n\n  componentWillReceiveProps(nextProps) {\n    this.updateFromProps(nextProps, this.props);\n  }\n\n  updateFromProps(props, prevProps) {\n    if (!this._isMounted) return;\n\n    const { fromRoute, toRoute } = props;\n    const direction = props.index >= (prevProps ? prevProps.index : Number.MIN_SAFE_INTEGER)\n      ? NavigationDirection.forward : NavigationDirection.back;\n\n    const index = prevProps ? props.index : 0;\n\n    if (toRoute !== this.state.toRoute\n      || fromRoute !== this.state.fromRoute\n      || index !== this.state.index\n      || direction !== this.state.direction) {\n      this.setState({\n        toRoute,\n        fromRoute,\n        direction,\n        index,\n      });\n    }\n  }\n\n  render() {\n    const { style, children } = this.props;\n    const { direction, fromRoute, toRoute, index, sharedElements, transitionElements } = this.state;\n    return (\n      <View\n        {...this.props}\n        style={[styles.container, style]}\n        ref={(ref) => this._viewRef = ref}\n        collapsable={false}\n      >\n        <ScreenContainer style={{ ...StyleSheet.absoluteFillObject }}>\n          {children}\n        </ScreenContainer>\n        <TransitionOverlayView\n          direction={direction}\n          fromRoute={fromRoute}\n          toRoute={toRoute}\n          index={index}\n          sharedElements={sharedElements}\n          transitionElements={transitionElements}\n        />\n      </View>\n    );\n  }\n\n  getDirectionForRoute = (name: string, route: string): RouteDirection => {\n    const { fromRoute, toRoute } = this.state;\n    if (!fromRoute && !toRoute) { return RouteDirection.unknown; }\n    if (!fromRoute) { return RouteDirection.to; } // First screen, always direction to\n    if (route === fromRoute) {\n      return RouteDirection.from;\n    } if (route === toRoute) {\n      return RouteDirection.to;\n    }\n    return RouteDirection.unknown;\n  }\n\n  getTransitionProgress = (useNative = true) => {\n    if (useNative) return this._transitionProgress;\n\n    if (!this._nonNativeTransitionProgress) {\n      this._nonNativeTransitionProgress = new Animated.Value(-1);\n      this._transitionProgress.addListener(Animated.event([{\n        value: this._nonNativeTransitionProgress }],\n      { useNativeDriver: false }));\n    }\n    return this._nonNativeTransitionProgress;\n  }\n\n  getRoutes = () => {\n    const { fromRoute, toRoute } = this.state;\n    return [fromRoute, toRoute].filter(r => r !== null);\n  }\n\n  getIsAnchored = (name: string, route: string) => {\n    const item = this._transitionItems.getItemByNameAndRoute(name, route);\n    if (!item) return false;\n\n    const { fromRoute, toRoute } = this.state;\n    const sharedElements = this._transitionItems.getSharedElements(fromRoute, toRoute);\n    if (sharedElements\n      && (sharedElements.find(p => p.fromItem.name === item.anchor && p.fromItem.route === route))\n      || sharedElements.find(p => p.toItem.name === item.anchor && p.toItem.route === route)) {\n      return true;\n    }\n    return false;\n  }\n\n  getItemByNameAndRoute = (\n    name: string, route: string,\n  ) => this._transitionItems.getItemByNameAndRoute(name, route)\n\n  getItemDelayInfo = (name: string, route: string) => {\n    const { fromRoute, toRoute } = this.state;\n    const transitionElements = this._transitionItems\n      .getItems()\n      .filter(itm => itm.route === route && !itm.shared && itm.delay);\n\n    const delayCount = transitionElements.length + 1;\n    let delayFactor = 0;\n    let delayIndex = 0;\n    if (fromRoute === route) {\n      delayFactor = 1;\n      delayIndex = 0;\n    } else if (toRoute === route) {\n      delayFactor = -1;\n      delayIndex = delayCount - 1;\n    }\n\n    for (let i = 0; i < transitionElements.length; i++) {\n      delayIndex += delayFactor;\n      if (transitionElements[i].name === name\n        && transitionElements[i].route === route) {\n        break;\n      }\n    }\n\n    return { delayCount, delayIndex };\n  }\n\n  getIsPartOfSharedTransition = (name: string, route: string) => {\n    const item = this._transitionItems.getItemByNameAndRoute(name, route);\n    if (!item || !item.shared) return false;\n\n    const { fromRoute, toRoute } = this.state;\n    const sharedElements = this._transitionItems.getSharedElements(fromRoute, toRoute);\n\n    if (sharedElements.find(pair => (pair.fromItem.name === item.name\n      && pair.fromItem.route === item.route)\n      || (pair.toItem.name === item.name && pair.toItem.route === item.route))) {\n      return true;\n    }\n    return false;\n  }\n\n  getDirection = () => {\n    const { direction } = this.state;\n    return direction;\n  }\n\n  getIndex = () => {\n    const { index } = this.state;\n    return index;\n  }\n\n  getIsPartOfTransition = (name: string, route: string) => {\n    const item = this._transitionItems.getItemByNameAndRoute(name, route);\n    if (!item || !(item.appear || item.disappear)) return false;\n\n    const { fromRoute, toRoute } = this.state;\n    const transitionElements = this._transitionItems.getTransitionElements(fromRoute, toRoute);\n\n    if (transitionElements.find(o => item.name === o.name && item.route === o.route)) {\n      return true;\n    }\n    return false;\n  }\n\n  async getViewMetrics():Metrics {\n    const nodeHandle = findNodeHandle(this._viewRef);\n    let viewMetrics: Metrics;\n    if (!nodeHandle) return viewMetrics;\n\n    const promise = new Promise(resolve => {\n      UIManager.measureInWindow(nodeHandle, (x, y, width, height) => {\n        viewMetrics = { x, y, width, height };\n        resolve();\n      });\n    });\n    await promise;\n    return viewMetrics;\n  }\n\n  async measureItems(\n    sharedElements: Map<TransitionItem, TransitionItem>,\n    transitionElements: Array<TransitionItem>,\n  ) {\n    const promises = [];\n    const viewMetrics = await this.getViewMetrics();\n    if (sharedElements) {\n      for (let i = 0; i < sharedElements.length; i++) {\n        const pair = sharedElements[i];\n        promises.push(this.measureItem(viewMetrics, pair.fromItem));\n        promises.push(this.measureItem(viewMetrics, pair.toItem));\n        if (pair.fromItem && pair.fromItem.anchors) {\n          for (let n = 0; n < pair.fromItem.anchors.length; n++) {\n            promises.push(this.measureItem(viewMetrics, pair.fromItem.anchors[n]));\n          }\n        }\n        if (pair.toItem && pair.toItem.anchors) {\n          for (let n = 0; n < pair.toItem.anchors.length; n++) {\n            promises.push(this.measureItem(viewMetrics, pair.toItem.anchors[n]));\n          }\n        }\n      }\n    }\n\n    if (transitionElements) {\n      for (let i = 0; i < transitionElements.length; i++) {\n        promises.push(this.measureItem(viewMetrics, transitionElements[i]));\n      }\n    }\n\n    if (promises.length > 0) await Promise.all(promises);\n  }\n\n  async measureItem(viewMetrics: Metrics, item: TransitionItem) {\n    const nodeHandle = item.getNodeHandle();\n    if (!nodeHandle) return;\n\n    await new Promise(resolve => {\n      UIManager.measureInWindow(nodeHandle, (x, y, width, height) => {\n        item.updateMetrics(viewMetrics, { x, y, width, height });\n        resolve();\n      });\n    });\n  }\n\n  _inUpdate: boolean = false;\n\n  componentDidUpdate() {\n    if (this._inUpdate) return;\n    const { fromRoute, toRoute } = this.state;\n    if (!fromRoute && !toRoute) return;\n\n    this._inUpdate = true;\n\n    // Wait a little bit to give the layout system some time to reconcile\n    let measureAndUpdateFunc = async () => {\n      const sharedElements = this._transitionItems.getSharedElements(fromRoute, toRoute);\n      const transitionElements = this._transitionItems.getTransitionElements(fromRoute, toRoute);\n\n      await this._interactionDonePromise;\n      await this.measureItems(sharedElements, transitionElements);\n\n      if (!sharedElements.find(p => !p.fromItem.metrics || !p.toItem.metrics)\n        && !transitionElements.find(i => !i.metrics)) {\n        // Update style based on calculation by re-rendering all transition elements.\n        // Ref, https://github.com/fram-x/FluidTransitions/issues/8\n        this._transitionItems.getItems().forEach(item => item.forceUpdate());\n\n        // HACK: Setting state in componentDidUpdate is not nice - but\n        // this is the only way we can notify the transitioner that we are\n        // ready to move along with the transition and we're trying to be nice\n        // by waiting a few milliseconds\n        this.setState((prevState) => ({\n          ...prevState,\n          sharedElements,\n          transitionElements,\n        }), () => {\n          const { onLayout } = this.props;\n          if (onLayout) onLayout();\n          this._runStartAnimation(transitionElements.length);\n          this._inUpdate = false;\n        });\n      }\n    };\n\n    measureAndUpdateFunc = measureAndUpdateFunc.bind(this);\n    setTimeout(measureAndUpdateFunc, 10);\n  }\n\n  async _runStartAnimation(numberOfTransitions: number) {\n    if (!this._shouldRunStartAnimation) { return; }\n\n    this._shouldRunStartAnimation = false;\n    const { getTransitionConfig } = this.context;\n    const { toRoute, navigation, index } = this.props;\n\n    if (index > 0) {\n      this._transitionProgress.setValue(index - 1);\n    }\n\n    const transitionSpec = getTransitionConfig\n      ? getTransitionConfig(toRoute, navigation) : {\n        timing: Animated.timing,\n        duration: 650,\n        easing: Easing.inOut(Easing.poly(4)),\n        isInteraction: true,\n        useNativeDriver: true,\n      };\n\n    const { timing } = transitionSpec;\n    delete transitionSpec.timing;\n    const animations = [\n      timing(this._transitionProgress, {\n        ...transitionSpec,\n        duration: numberOfTransitions === 0 ? 25 : transitionSpec.duration,\n        toValue: index,\n      }),\n    ];\n\n    Animated.parallel(animations).start();\n  }\n\n  componentDidMount() {\n    this._isMounted = true;\n    this.updateFromProps({ ...this.props, index: -1 });\n    // check for transition elements - we don't need to wait for transitions\n    // if we don't have any appearing elements\n    const { fromRoute, toRoute } = this.props;\n    const te = this._transitionItems.getTransitionElements(fromRoute, toRoute);\n    if (te.length > 0) {\n      InteractionManager.runAfterInteractions(this._interactionDonePromiseDone);\n    } else {\n      this._interactionDonePromiseDone();\n    }\n  }\n\n  componentWillUnmount() {\n    this._isMounted = false;\n  }\n\n  static childContextTypes = {\n    register: PropTypes.func,\n    unregister: PropTypes.func,\n    getTransitionProgress: PropTypes.func,\n    getDirectionForRoute: PropTypes.func,\n    getDirection: PropTypes.func,\n    getIndex: PropTypes.func,\n    getIsPartOfSharedTransition: PropTypes.func,\n    getIsPartOfTransition: PropTypes.func,\n    getRoutes: PropTypes.func,\n    getIsAnchored: PropTypes.func,\n    getItemByNameAndRoute: PropTypes.func,\n    getItemDelayInfo: PropTypes.func,\n  }\n\n  static contextTypes = {\n    getTransitionConfig: PropTypes.func,\n  }\n\n  getChildContext() {\n    return {\n      register: (item) => this._transitionItems.add(item),\n      unregister: (name, route) => this._transitionItems.remove(name, route),\n      getTransitionProgress: this.getTransitionProgress,\n      getDirectionForRoute: this.getDirectionForRoute,\n      getIndex: () => this.getIndex(),\n      getDirection: () => (this.getDirection() || NavigationDirection.unknown),\n      getIsPartOfSharedTransition: this.getIsPartOfSharedTransition,\n      getIsPartOfTransition: this.getIsPartOfTransition,\n      getIsAnchored: this.getIsAnchored,\n      getRoutes: this.getRoutes,\n      getItemByNameAndRoute: this.getItemByNameAndRoute,\n      getItemDelayInfo: this.getItemDelayInfo,\n    };\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n    overflow: 'hidden',\n  },\n});\n"]},"metadata":{},"sourceType":"module"}